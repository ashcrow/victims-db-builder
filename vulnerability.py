import yaml, httplib, string
import urllib2
import re
import itertools
import sys

#COMMON_FIELDS = {
#    'cve': FieldValidator([is_string, is_cve]),
#    'title': FieldValidator([is_string]),
#    'description': FieldValidator([is_text], False),
#    'cvss_v2': FieldValidator([is_cvss_v2], False),
#    'references': FieldValidator([is_references], False),
#    'affected': FieldValidator([is_affected])
#}

#LANGUAGE_FIELDS = {
#    'python': {
#        'name': FieldValidator([is_string]),
#        'version': FieldValidator([is_version]),
#        'fixedin': FieldValidator([is_version], False),
#        'unaffected': FieldValidator([is_version], False),
#    },
#    'java': {
#        'groupId': FieldValidator([is_string]),
#        'artifactId': FieldValidator([is_string]),
#        'version': FieldValidator([is_version]),
#        'fixedin': FieldValidator([is_version], False),
#        'unaffected': FieldValidator([is_version], False),
#    }
#}

#VERSION_REGEX = regex_compile(
#    r'^(?P<condition>[><=]=)'
#    r'(?P<version>[^, ]+)'
#    r'(?:,(?P<series>[^, ]+)){0,1}$'
#)

##############################################################
## Vulnerability class
## Used for both parsing yaml file and building individual jar files
##############################################################

class Vulnerability:

    #This Base URL will only work for Java, need to add for Python and Ruby
    indexBaseUrl="http://mvnrepository.com/artifact/"


    ## upper range of z maintenance release in maven page
    maxRange = 99

    listVer = []

    ## For loading in Yaml info
    def __init__(self,document):
        try:
            data = yaml.load(file(document))
            self.cve = data['cve']
            self.title = data['title']
            self.description = data['description']
            self.cvss_v2 = data['cvss_v2']
            self.references = data['references']
            self.affected = data['affected']
    #TODO this will only assign last artifact/group in affected list
    ##If there are mulitiple affected, need to create an affected list
            for j in self.affected:
                self.groupId = j['groupId']
                self.artifactId = j['artifactId']
                self.verRanges = j['version']
                self.anchor = "/artifact/" + self.groupId + "/" + self.artifactId + "/"
            self.fixVersionRange()
        except IOError, e:
            print "Returns :", e
            sys.exit()

    ## Prints out basics
    def print_flaw(self):
        print "CVE= " + self.cve
        print "groupId= " + self.groupId
        print "artifactId= " + self.artifactId
        rangeCount = 1
        for r in self.verRanges:
            print 'Version ' + str(rangeCount) + ': ' + str(r)
            rangeCount += 1

    # Remove duplicates and merge ranges in the version listing
    def fixVersionRange(self):
        tmpVerRanges = []
        if (len(self.verRanges) > 1):
            for a, b in itertools.combinations(self.verRanges,2):
                AListSplit = self.genVerString(a)
                AList = string.split(AListSplit[0], '.')
                BListSplit = self.genVerString(b)
                BList = string.split(BListSplit[0], '.')
                AX = AList[0]; AY=AList[1]; AZ=AList[2]
                BX = BList[0]; BY=BList[1]; BZ=BList[2]

                if ((AX != BX) or (AY != BY)):
                    if(not a in tmpVerRanges): tmpVerRanges.append(a)
                    if(not b in tmpVerRanges): tmpVerRanges.append(b)
                else:
                    if(a[0] == b[0]):
                        # if the same symbol for the same X.Y version,
                        # assume last entry is correct
                        # switch out old for new version
                        if(not b in tmpVerRanges): tmpVerRanges.append(b)
                    else:
                        # symbols are different, need to combine two versions
                        if(a[0] == '<' and  b[0] == '>'):
                            if(AZ < BZ):
                                if(not a in tmpVerRanges): tmpVerRanges.append(a)
                                if(not b in tmpVerRanges): tmpVerRanges.append(b)
                            else:
                                tmpVersion = '<=' + str(AListSplit[0]) + ',' + BListSplit[0]
                                tmpVerRanges.append(tmpVersion)
                        else:
                            if(AZ > BZ):
                                if(not a in tmpVerRanges): tmpVerRanges.append(a)
                                if(not b in tmpVerRanges): tmpVerRanges.append(b)
                            else:
                                tmpVersion = '<=' + str(BListSplit[0]) + ',' + AListSplit[0]
                                tmpVerRanges.append(tmpVersion)
            self.verRanges = tmpVerRanges

    def splitRange(self, numRange):
        tmpVers = []
        if(',' in numRange):
            tmpVers =  string.split(numRange, ',')
        else:
            tmpBase = self.retlowHigh(numRange)
            tmpVers.append(numRange)
            tmpVers.append(tmpBase[0])

        return tmpVers

    ## Turn version into list, without beginning symbols
    def genVerString(self, version):
        numRangeArray = self.splitRange(version[2:])
        toScale = numRangeArray[0].count('.')
        fromScale = numRangeArray[1].count('.')
        fromValue = numRangeArray[1]
        while fromScale < toScale:
            fromValue += '.0'
            fromScale = fromValue.count('.')
        numRangeArray[1] = fromValue
        return numRangeArray

    # Assumes string "4.0.2"
    # Returns list of [4.0,2] for looping as float
    def retlowHigh(self, string):
        valList = []
        k = string.rfind(".")
        valList.append(string[:k])
        valList.append(string[k+1:])
        return valList

    ## Opens Maven file for product, and checks through the version range to see whether
    ## it is listed as a release on the page
    ## Checks page for ex.: "/artifact/org.springframework/spring-web/4.0.9.RELEASE"
    ## Example range: <=3.2.13,3.2

    def checkMvnVer(self):
        #TODO This will not work for Python and Ruby
        coords = self.indexBaseUrl + self.groupId + "/" + self.artifactId
        try:
            response = urllib2.urlopen(coords)
        except urllib2.URLError, e:
            if not hasattr(e, "code"):
                raise
            response = e
            print "Error with MavenPage:", response.code, response.msg
            return []

        HTMLPage = response.read()

        for r in self.verRanges:
            listString = self.genVerString(r)

            #split out values, for ['9.2.8', '9.2.0']
            valList= self.retlowHigh(listString[0])
            firstY = float(valList[0])
            firstZ = int(valList[1])
            valList= self.retlowHigh(listString[1])
            secondY = float(valList[0])
            secondZ = int(valList[1])

            if (r[0] == '>'):
                self.sortedAddVer(HTMLPage, coords, firstY, self.maxRange, firstY, firstZ)
            elif (r[0] == '<'):
                self.sortedAddVer(HTMLPage, coords, firstY, firstZ, secondY, secondZ)
            else:
                self.sortedAddVer(HTMLPage, coords, firstY, firstZ, firstY, firstZ)

        return self.listVer

    def sortedAddVer(self, HTMLPage, coords, AY, AZ, BY, BZ):
        #print 'AY:%.1f, AZ:%d, BY:%.1f, BZ:%d' % (AY,AZ,BY,BZ)
        ver = BY
        while ver >= BY and ver <= AY:
            if (ver == BY and ver == AY):
                for i in range (BZ,AZ+1):
                    self.addVer(ver, i, HTMLPage, coords)
            elif (ver == BY):
                for i in range (BZ, self.maxRange):
                    self.addVer(ver, i, HTMLPage, coords)
            elif (ver == AY):
                for i in range(AZ+1):
                    self.addVer(ver, i, HTMLPage, coords)
            else:
                for i in range(self.maxRange):
                    self.addVer(ver, i, HTMLPage, coords)
            ver += 0.1

    def addVer(self, ver, i, HTMLPage, coords):
        tmpVers = str(ver) + "." + str(i) + "."
        tmpAnchor = self.anchor + tmpVers
        results = self.regex_search(tmpVers, HTMLPage)
        if len(results) > 0:
            for (fullVer) in results:
                self.listVer.append(fullVer)
       # else:
        #    print tmpAnchor + " not find on " + coords

    def regex_search(self, tmpVers, target):
        #print 'tmpVers: %s' % tmpVers
        searchString = self.artifactId + '/' + tmpVers
        searchString = searchString.replace('.', '\\.')
        searchString += '([^"/]+)'
        #print 'search with regex: %s' % searchString
        uniqueResults = set()
        for result in re.findall(searchString, target):
            uniqueResults.add("%s%s" % (tmpVers, result))
        return uniqueResults
